<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OmniSlice – 3D Cutaway Viewer</title>
  <link rel="icon" type="image/x-icon" href="../wheel.ico">
  <script src="../js/utilities/nav.js"></script>
  <link rel="stylesheet" href="omnibase.css">
  <style>
    /* 3D canvas specific styles */
    .chart-container canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #0f0f23;
    }
  </style>
</head>
<body>
  <header class="header">
    <h1>OmniSlice</h1>
    <p class="subtitle">3D sphere with adjustable cutaway. Drag to rotate view, scroll to zoom.</p>
  </header>
  
  <div class="layout">
    <div class="chart-container" id="chart-container"></div>
    <div class="controls-wrapper">
      <div class="multiscroller-strip" id="multiscroller"></div>
      <div class="controls" id="controls"></div>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script src="warped-polygon.js"></script>
  <script src="omnibase.js"></script>
  
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ============================================================
    // Presets
    // ============================================================
    
    const PRESETS = {
      'Wide': {
        wedgeStart: 0,
        wedgeAngle: 120,
        coreRadius: 0.6,
        planeOpacity: 1.0,
        coreOpacity: 1.0,
        zoom: 1.0,
        rotation: 0,
        light1: 1.0,
        light2: 0.3
      },
      'Narrow': {
        wedgeStart: 90,
        wedgeAngle: 60,
        coreRadius: 0.75,
        planeOpacity: 0.9,
        coreOpacity: 0.0,
        zoom: 1.0,
        rotation: 0,
        light1: 1.0,
        light2: 0.3
      }
    };

    // ============================================================
    // Slider Configuration
    // ============================================================
    
    const SLIDER_CONFIG = [
      { 
        group: 'Presets', 
        id: 'presets', 
        abbrev: 'Pre',
        type: 'presets' 
      },
      {
        group: 'View',
        id: 'view',
        abbrev: 'View',
        sliders: [
          { id: 'zoom', label: 'Zoom', min: 0.1, max: 2, step: 0.01, default: 1.0 },
          { id: 'rotation', label: 'Rotation', min: 0, max: 360, step: 1, default: 0, format: 'degInt' }
        ]
      },
      { 
        group: 'Cutaway', 
        id: 'cutaway', 
        abbrev: 'Cut',
        sliders: [
          { id: 'wedgeStart', label: 'Wedge start', min: 0, max: 360, step: 1, default: 0, format: 'degInt' },
          { id: 'wedgeAngle', label: 'Wedge angle', min: 0, max: 180, step: 1, default: 90, format: 'degInt' }
        ]
      },
      { 
        group: 'Core', 
        id: 'core', 
        abbrev: 'Core',
        sliders: [
          { id: 'coreRadius', label: 'Core radius', min: 0.2, max: 0.9, step: 0.05, default: 0.6 }
        ]
      },
      { 
        group: 'Planes', 
        id: 'planes', 
        abbrev: 'Pln',
        sliders: [
          { id: 'planeOpacity', label: 'Plane opacity', min: 0, max: 1, step: 0.05, default: 0.9 },
          { id: 'coreOpacity', label: 'Core on planes', min: 0, max: 1, step: 0.05, default: 1.0 }
        ]
      },
      {
        group: 'Lighting',
        id: 'lighting',
        abbrev: 'Lit',
        sliders: [
          { id: 'light1', label: 'Key light', min: 0, max: 2, step: 0.05, default: 1.0 },
          { id: 'light2', label: 'Fill light', min: 0, max: 2, step: 0.05, default: 0.3 }
        ]
      }
    ];

    // ============================================================
    // Three.js Scene Setup
    // ============================================================
    
    class SphereScene {
      constructor(container) {
        this.container = container;
        
        // Calculate base distance for 3x larger initial view
        const originalDistance = Math.sqrt(24);
        this.baseDistance = originalDistance / 2.5;
        
        // Scene setup
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(
          75, 
          container.clientWidth / container.clientHeight, 
          0.1, 
          1000
        );
        
        // Set initial camera position (3x closer than original)
        const direction = new THREE.Vector3(2, 2, 4).normalize();
        this.camera.position.copy(direction.multiplyScalar(this.baseDistance));
        
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(container.clientWidth, container.clientHeight);
        this.renderer.localClippingEnabled = true;
        container.appendChild(this.renderer.domElement);
        
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.minDistance = this.baseDistance / 2;
        this.controls.maxDistance = this.baseDistance / 0.1;
        
        this._settingZoom = false;
        this.onZoomChange = null;
        
        this.controls.addEventListener('change', () => {
          if (!this._settingZoom && this.onZoomChange) {
            this.onZoomChange(this.getZoom());
          }
        });
        
        // Create sphere group (for rotation independent of camera/lights)
        this.sphereGroup = new THREE.Group();
        this.scene.add(this.sphereGroup);
        
        // Lighting (added to scene, not sphereGroup)
        this.light1 = new THREE.DirectionalLight(0xffffff, 1);
        this.light1.position.set(5, 5, 5);
        this.scene.add(this.light1);
        
        this.light2 = new THREE.DirectionalLight(0xffffff, 0.3);
        this.light2.position.set(-5, -5, -5);
        this.scene.add(this.light2);
        
        this.scene.add(new THREE.AmbientLight(0x606060));

        // Clipping planes
        this.clipPlane1 = new THREE.Plane(new THREE.Vector3(1, 0, 0), 0);
        this.clipPlane2 = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        this.clippingPlanes = [this.clipPlane1, this.clipPlane2];
        
        this.createMaterials();
        this.createGeometry();
        this.animate();
      }
      
      getZoom() {
        const distance = this.camera.position.length();
        return Math.max(0.1, Math.min(2, this.baseDistance / distance));
      }
      
      setZoom(zoomValue) {
        this._settingZoom = true;
        const clampedZoom = Math.max(0.1, Math.min(2, zoomValue));
        const targetDistance = this.baseDistance / clampedZoom;
        const direction = this.camera.position.clone().normalize();
        this.camera.position.copy(direction.multiplyScalar(targetDistance));
        this.controls.update();
        this._settingZoom = false;
      }
      
      createMaterials() {
        const textureLoader = new THREE.TextureLoader();
        const earthTex = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
        
        this.crustMat = new THREE.MeshPhongMaterial({ 
          map: earthTex, 
          clippingPlanes: this.clippingPlanes,
          clipIntersection: true,
          side: THREE.DoubleSide 
        });
        
        this.coreMat = new THREE.MeshPhongMaterial({ 
          color: 0xff6600,
          emissive: 0x441100,
          clippingPlanes: this.clippingPlanes,
          clipIntersection: true,
          side: THREE.DoubleSide
        });
        
        this.gridMat = new THREE.MeshBasicMaterial({ 
          color: 0xffffff, 
          wireframe: true, 
          transparent: true, 
          opacity: 0.2,
          clippingPlanes: this.clippingPlanes,
          clipIntersection: true 
        });
        
        this.planeMat1 = new THREE.MeshPhongMaterial({ 
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.9
        });
      
        this.planeMat2 = new THREE.MeshPhongMaterial({ 
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.9
        });
        
        this.updateRadialTexture(0.6, 1.0);
      }
      
      createGeometry() {
        // All geometry added to sphereGroup for unified rotation
        this.crust = new THREE.Mesh(new THREE.SphereGeometry(1, 64, 64), this.crustMat);
        this.sphereGroup.add(this.crust);
        
        this.coreRadius = 0.6;
        this.core = new THREE.Mesh(new THREE.SphereGeometry(this.coreRadius, 64, 64), this.coreMat);
        this.sphereGroup.add(this.core);
        
        this.grid = new THREE.Mesh(new THREE.SphereGeometry(1.005, 32, 32), this.gridMat);
        this.sphereGroup.add(this.grid);
        
        const planeGeom = new THREE.CircleGeometry(1, 64, -Math.PI / 2, Math.PI);
        
        this.plane1 = new THREE.Mesh(planeGeom, this.planeMat1);
        this.plane1.rotation.y = Math.PI / 2;
        this.sphereGroup.add(this.plane1);
        
        this.plane2 = new THREE.Mesh(planeGeom, this.planeMat2);
        this.plane2.rotation.z = Math.PI;
        this.sphereGroup.add(this.plane2);
      }
      
      createRadialTexture(coreRadius, coreOpacity) {
        const canvas = document.createElement('canvas');
        const size = 512;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        const centerX = size / 2;
        const centerY = size / 2;
        const maxRadius = size / 2;
        
        ctx.clearRect(0, 0, size, size);
        
        // Mantle gradient
        const mantleGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
        mantleGradient.addColorStop(0, '#d4a373');
        mantleGradient.addColorStop(0.5, '#8b6f47');
        mantleGradient.addColorStop(1, '#654321');
        
        ctx.fillStyle = mantleGradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
        ctx.fill();
        
        const coreRadiusPixels = maxRadius * coreRadius;
        
        if (coreOpacity < 1.0) {
          ctx.globalCompositeOperation = 'destination-out';
          ctx.fillStyle = `rgba(0, 0, 0, ${1.0 - coreOpacity})`;
          ctx.beginPath();
          ctx.arc(centerX, centerY, coreRadiusPixels, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
        }
        
        if (coreOpacity > 0) {
          ctx.globalAlpha = coreOpacity;
          const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreRadiusPixels);
          coreGradient.addColorStop(0, '#ffff00');
          coreGradient.addColorStop(0.3, '#ff8800');
          coreGradient.addColorStop(0.7, '#ff4500');
          coreGradient.addColorStop(1, '#cc3300');
          
          ctx.fillStyle = coreGradient;
          ctx.beginPath();
          ctx.arc(centerX, centerY, coreRadiusPixels, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1.0;
        }
        
        // Detail lines
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.lineWidth = 1;
        for (let r = 0.2; r <= 1; r += 0.2) {
          ctx.beginPath();
          ctx.arc(centerX, centerY, maxRadius * r, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
      }
      
      // ============================================================
      // Single update method - all params handled here (DRY)
      // ============================================================
      
      update(params) {
        // Sphere rotation (Y-axis) - calculate first, used for clipping planes
        const rotationRad = (params.rotation * Math.PI) / 180;
        this.sphereGroup.rotation.y = rotationRad;
        
        // Cutaway planes - apply sphere rotation to clipping plane normals
        const radStart = -(params.wedgeStart * Math.PI) / 180;
        const rad1 = radStart - rotationRad;
        this.clipPlane1.normal.set(Math.cos(rad1), 0, Math.sin(rad1));
        this.plane1.rotation.y = -radStart + Math.PI / 2;
        
        const radEnd = radStart + Math.PI - (params.wedgeAngle * Math.PI) / 180;
        const rad2 = radEnd - rotationRad;
        this.clipPlane2.normal.set(Math.cos(rad2), 0, Math.sin(rad2));
        this.plane2.rotation.y = -radEnd + Math.PI / 2;
        
        // Core radius (only recreate geometry if changed)
        if (this.coreRadius !== params.coreRadius) {
          this.coreRadius = params.coreRadius;
          this.sphereGroup.remove(this.core);
          this.core.geometry.dispose();
          this.core.geometry = new THREE.SphereGeometry(params.coreRadius, 64, 64);
          this.sphereGroup.add(this.core);
        }
        
        // Plane opacity & texture
        this.planeMat1.opacity = params.planeOpacity;
        this.planeMat2.opacity = params.planeOpacity;
        this.updateRadialTexture(params.coreRadius, params.coreOpacity);
        
        // Lighting intensities
        this.light1.intensity = params.light1;
        this.light2.intensity = params.light2;
        
        // Camera zoom
        this.setZoom(params.zoom);
      }
      
      updateRadialTexture(coreRadius, coreOpacity) {
        if (this.radialTexture) this.radialTexture.dispose();
        this.radialTexture = this.createRadialTexture(coreRadius, coreOpacity);
        this.planeMat1.map = this.radialTexture;
        this.planeMat2.map = this.radialTexture;
        this.planeMat1.needsUpdate = true;
        this.planeMat2.needsUpdate = true;
      }
      
      resize() {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
      }
      
      animate() {
        requestAnimationFrame(() => this.animate());
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
      }
    }

    // ============================================================
    // Initialize
    // ============================================================
    
    const container = document.getElementById('chart-container');
    const sphereScene = new SphereScene(container);
    
    const base = new window.OmniBase({
      elements: {
        container: container,
        controls: document.getElementById('controls'),
        multiscroller: document.getElementById('multiscroller')
      },
      sliderConfig: SLIDER_CONFIG,
      presets: PRESETS,
      defaultPreset: 'Wide',
      enablePanZoom: false,
      aspectRatio: 1,
      hintHtml: '<b>Drag</b> to rotate view. <b>Scroll</b> to zoom.<br><b>Rotation</b> spins the sphere itself.',
      
      onRender: (params) => sphereScene.update(params),
      onResize: () => sphereScene.resize()
    });
    
    // Sync OrbitControls zoom → slider
    sphereScene.onZoomChange = (zoom) => base.updateSlider('zoom', zoom, false);
    
    window.addEventListener('resize', () => sphereScene.resize());
  </script>
</body>
</html>