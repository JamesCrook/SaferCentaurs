<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OmniChart ‚Äî Unified Charting</title>
  <link rel="icon" type="image/x-icon" href="../wheel.ico">
  <script src="../js/utilities/nav.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body { 
      font-family: system-ui, -apple-system, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      overflow: hidden;
    }
    
    /* Header */
    .header {
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      padding: 0 10px;
    }
    
    .header h1 {
      font-size: 16px;
      font-weight: 600;
      color: #fff;
    }
    
    .subtitle {
      display: none;
    }
    
    .header-right {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .legend-toggle {
      background: #16213e;
      border: none;
      color: #555;
      font-size: 12px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s;
      filter: grayscale(1);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .legend-toggle:hover {
      background: #1e2a4a;
    }
    
    .legend-toggle.active {
      background: #3a3a4a;
      color: #888;
    }
    
    /* Main Layout */
    .layout {
      display: flex;
      flex-direction: row;
      gap: 15px;
      padding: 10px;
      height: calc(100vh - 30px);
    }
    
    /* Chart Container */
    .chart-container {
      flex: 1;
      background: #16213e;
      border-radius: 12px;
      padding: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      cursor: grab;
      min-width: 0;
    }
    
    .chart-container:active { cursor: grabbing; }
    
    .chart-container svg {
      background: #0f0f23;
      border-radius: 8px;
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
    }
    
    /* Controls Wrapper */
    .controls-wrapper {
      display: flex;
      width: 320px;
      flex-shrink: 0;
      min-height: 0;
    }
    
    /* Multiscroller Strip */
    .multiscroller-strip {
      width: 32px;
      flex-shrink: 0;
      background: #16213e;
      border-radius: 12px 0 0 12px;
      display: flex;
      flex-direction: column;
      padding: 4px 0;
    }
    
    /* Center content-sized buttons when using full names */
    .multiscroller-strip.full-names {
      justify-content: flex-start;
    }
    
    .strip-btn {
      flex: 1;
      min-height: 30px;
      max-height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: #666;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.2s;
      writing-mode: vertical-lr;
    }
    
    /* When showing full names, buttons size to their content */
    .multiscroller-strip.full-names .strip-btn {
      flex: 0 0 auto;
      min-height: 0;
      max-height: none;
      padding: 6px 0;
    }
    
    .strip-btn:hover {
      color: #4fc3f7;
      background: rgba(79, 195, 247, 0.1);
    }
    
    /* Button won't do anything - section already visible/at-top */
    .strip-btn.inactive {
      color: #3a3a4a;
    }

    .strip-btn.active {
      color: #4fc3f7;
      background: rgba(79, 195, 247, 0.15);
    }
    
    .strip-btn.inactive:hover {
      color: #3a3a4a;
      background: transparent;
    }
    
    /* When multiscroller is unlocked (legend hidden), show grab cursor */
    .multiscroller-unlocked .strip-btn {
      cursor: grab;
    }
    
    .multiscroller-unlocked .strip-btn:active {
      cursor: grabbing;
    }
    
    /* Controls Panel */
    .controls {
      position: relative;
      flex: 1;
      background: #16213e;
      border-radius: 0 12px 12px 0;
      padding: 12px 12px 12px 8px;
      overflow-y: auto;
      overflow-x: hidden;
    }
    
    .controls::-webkit-scrollbar {
      width: 6px;
    }
    
    .controls::-webkit-scrollbar-track {
      background: #0f0f23;
      border-radius: 3px;
    }
    
    .controls::-webkit-scrollbar-thumb {
      background: #4fc3f7;
      border-radius: 3px;
    }
    
    .control-group { 
      margin-bottom: 14px;
      scroll-margin-top: 4px;
    }
    
    .control-group h3 {
      font-size: 10px;
      text-transform: uppercase;
      color: #666;
      margin-bottom: 6px;
      letter-spacing: 1px;
    }
    
    .control { margin-bottom: 8px; }
    .control label { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 2px; }
    .control label span:last-child { color: #4fc3f7; font-family: monospace; font-size: 10px; }
    
    input[type="range"] {
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: #0f0f23;
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #4fc3f7;
      cursor: pointer;
    }
    
    .presets { display: flex; flex-wrap: wrap; gap: 4px; }
    
    .preset-btn {
      padding: 4px 8px;
      border: 1px solid #4fc3f7;
      background: transparent;
      color: #4fc3f7;
      border-radius: 4px;
      cursor: pointer;
      font-size: 10px;
      transition: all 0.2s;
    }
    
    .preset-btn:hover, .preset-btn.active { background: #4fc3f7; color: #1a1a2e; }
    
    /* Hint text - large screens only */
    .hint {
      display: none;
      font-size: 11px;
      color: #555;
      margin-top: 12px;
      line-height: 1.5;
    }
    
    @media (min-width: 1000px) {
      .hint {
        display: block;
      }
    }
    
    /* Legend (inside SVG, controlled by toggle) */
    .legend-hidden .chart-legend { display: none; }
    
    /* ============================================
       RESPONSIVE: Portrait mobile (‚â§800px width)
       ============================================ */
    @media (max-width: 800px) and (orientation: portrait) {
      .layout {
        flex-direction: column;
        gap: 10px;
        padding: 8px;
      }
      
      .chart-container {
        flex: 0 0 auto;
        width: 100%;
        aspect-ratio: 800 / 650;
        min-height: 0;
        /* Ensure minimum 210px for controls: header 30px + controls 210px + gaps 26px */
        max-height: calc(100vh - 266px);
      }
      
      .controls-wrapper {
        width: 100%;
        flex: 1;
        min-height: 210px;
        max-height: none;
      }
      
      .multiscroller-strip {
        border-radius: 12px 0 0 12px;
      }
      
      .controls {
        border-radius: 0 12px 12px 0;
      }
    }
    
    /* Landscape or wider screens - use grid so controls extend full height */
    @media (min-width: 801px), (orientation: landscape) {
      body {
        display: grid;
        grid-template-columns: 1fr 320px;
        grid-template-rows: auto 1fr;
        height: 100vh;
        gap: 0 10px;
        padding: 10px;
      }
      
      .header {
        grid-column: 1;
        grid-row: 1;
        height: auto;
      }
      
      .layout {
        display: contents;
      }
      
      .chart-container {
        grid-column: 1;
        grid-row: 2;
        flex: unset;
        min-height: 0;
      }
      
      .controls-wrapper {
        grid-column: 2;
        grid-row: 1 / 3;
        width: auto;
        height: 100%;
      }
    }
    
    /* Large landscape - taller header */
    @media (min-width: 1000px) {
      .header {
        flex-direction: column;
        padding: 10px;
      }
      
      .header h1 {
        font-size: 24px;
        margin-bottom: 5px;
      }
      
      .subtitle {
        display: block;
        color: #888;
        font-size: 14px;
        text-align: center;
      }
      
      .header-right {
        top: 10px;
        transform: none;
      }
    }
    
    /* Very small screens */
    @media (max-height: 500px) {
      .controls-wrapper {
        min-height: 150px;
      }
    }
  </style>
</head>
<body>
  <header class="header">
    <h1>OmniChart</h1>
    <p class="subtitle">One engine, all charts. Drag to pan, scroll to zoom, use sliders to morph.</p>
    <div class="header-right">
      <button class="legend-toggle active" id="legend-toggle">üóù</button>
    </div>
  </header>
  
  <div class="layout">
    <div class="chart-container" id="chart-container">
      <svg id="chart" viewBox="0 0 800 650" preserveAspectRatio="xMidYMid meet"></svg>
    </div>
    <div class="controls-wrapper">
      <div class="multiscroller-strip" id="multiscroller">
        <!-- Buttons generated by JS -->
      </div>
      <div class="controls" id="controls">
        <!-- Controls generated by JS -->
      </div>
    </div>
  </div>

<script>
// ============================================================
// Mini Vector Library
// ============================================================

const V = {
  create: (x, y) => ({ x, y }),
  add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
  sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y }),
  scale: (v, s) => ({ x: v.x * s, y: v.y * s }),
  lerp: (a, b, t) => ({ x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t }),
  dist: (a, b) => Math.hypot(b.x - a.x, b.y - a.y),
  fromPolar: (r, angle) => ({ x: r * Math.cos(angle), y: r * Math.sin(angle) }),
  addPolar: (center, r, angle) => V.add(center, V.fromPolar(r, angle)),
  mid: (a, b) => V.scale(V.add(a, b), 0.5),
  perp: (v) => ({ x: -v.y, y: v.x }),
  normalize: (v) => {
    const len = Math.hypot(v.x, v.y);
    return len > 0 ? V.scale(v, 1 / len) : { x: 0, y: 0 };
  },
  rotate: (v, center, angle) => {
    const cos = Math.cos(angle), sin = Math.sin(angle);
    const d = V.sub(v, center);
    return V.add(center, { x: d.x * cos - d.y * sin, y: d.x * sin + d.y * cos });
  }
};

const lerp = (a, b, t) => a + (b - a) * t;


// ============================================================
// WarpedPolygon - Unified quadrilateral with bend-based arc edges
// ============================================================

const WarpedPolygon = {
  path(corners, bends) {
    let d = `M ${corners[0].x} ${corners[0].y}`;
    for (let i = 0; i < 4; i++) {
      d += this._edge(corners[i], corners[(i + 1) % 4], bends[i]);
    }
    return d + ' Z';
  },
  
  topPath(corners, bends) {
    const p1 = corners[2], p2 = corners[3];
    return `M ${p1.x} ${p1.y}` + this._edge(p1, p2, bends[2]);
  },
  
  _getArcParams(p1, p2, bend) {
    const chord = V.sub(p2, p1);
    const chordLength = Math.hypot(chord.x, chord.y);
    const midpoint = V.mid(p1, p2);
    
    const halfBend = Math.abs(bend) / 2;
    const sinHalf = Math.sin(halfBend);
    if (sinHalf < 0.0001) return null;
    
    const radius = chordLength / (2 * sinHalf);
    const distToCenter = radius * Math.cos(halfBend);
    const perp = V.normalize(V.perp(chord));
    const sign = bend > 0 ? 1 : -1;
    const center = V.add(midpoint, V.scale(perp, -sign * distToCenter));
    
    const startAngle = Math.atan2(p1.y - center.y, p1.x - center.x);
    const endAngle = Math.atan2(p2.y - center.y, p2.x - center.x);
    const counterclockwise = bend > 0;
    
    return { center, radius, startAngle, endAngle, counterclockwise };
  },
  
  _edge(p1, p2, bend) {
    const chord = V.dist(p1, p2);
    if (chord < 0.001) return '';
    
    if (!bend || Math.abs(bend) < 0.01) {
      return ` L ${p2.x} ${p2.y}`;
    }
    
    const arcParams = this._getArcParams(p1, p2, bend);
    if (!arcParams) {
      return ` L ${p2.x} ${p2.y}`;
    }
    
    const { radius, counterclockwise, startAngle, endAngle } = arcParams;
    
    if (radius > chord * 100) {
      return ` L ${p2.x} ${p2.y}`;
    }
    
    let angleDiff = endAngle - startAngle;
    if (counterclockwise) {
      if (angleDiff < 0) angleDiff += Math.PI * 2;
    } else {
      if (angleDiff > 0) angleDiff -= Math.PI * 2;
    }
    const largeArc = Math.abs(angleDiff) > Math.PI ? 0 : 1;
    const sweep = counterclockwise ? 0 : 1;
    
    return ` A ${radius} ${radius} 0 ${largeArc} ${sweep} ${p2.x} ${p2.y}`;
  }
};


// ============================================================
// OmniChart Core Engine
// ============================================================

const OmniChart = (function() {
  
  const COLORS = ['#4fc3f7', '#81c784', '#ffb74d', '#f06292', '#ba68c8', '#4db6ac', '#fff176', '#a1887f'];
  const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const PRODUCTS = ['Product A', 'Product B', 'Product C', 'Product D', 'Product E'];
  const NUM_PRODUCTS = 5;
  
  const seededRandom = (seed) => {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  };
  
  const generateData = (numCategories) => {
    const labels = MONTHS.slice(0, numCategories);
    const series = [];
    for (let s = 0; s < NUM_PRODUCTS; s++) {
      const values = [];
      for (let c = 0; c < numCategories; c++) {
        values.push(15 + Math.floor(seededRandom(s * 100 + c * 7 + 42) * 40));
      }
      series.push({ name: PRODUCTS[s], values });
    }
    return { labels, series };
  };
  
  const svgNS = 'http://www.w3.org/2000/svg';
  const createElement = (tag) => document.createElementNS(svgNS, tag);
  
  const getDrawOrder = (focusProduct, numProducts) => {
    const order = [];
    for (let p = 0; p < numProducts; p++) {
      order.push((focusProduct - 1 + p) % NUM_PRODUCTS);
    }
    return order;
  };
  
  const calcAllSegments = (data, params) => {
    const { stack, normalize, focusProduct, numProducts } = params;
    const numCats = data.labels.length;
    const drawOrder = getDrawOrder(focusProduct, numProducts);
    
    const useAllForNorm = numProducts === 1 || numProducts === NUM_PRODUCTS;
    const normIndices = useAllForNorm ? [0, 1, 2, 3, 4] : drawOrder;
    
    const categoryTotals = data.labels.map((_, i) => 
      normIndices.reduce((sum, idx) => sum + data.series[idx].values[i], 0)
    );
    const maxTotal = Math.max(...categoryTotals);
    const maxSingle = Math.max(...drawOrder.flatMap(idx => data.series[idx].values));
    
    const result = [];
    
    for (let i = 0; i < numCats; i++) {
      const catSegs = [];
      let stackedY = 0;
      
      for (const origIdx of drawOrder) {
        const rawValue = data.series[origIdx].values[i];
        const normVal = categoryTotals[i] > 0 ? rawValue / categoryTotals[i] : 0;
        const rawScaled = rawValue / maxTotal;
        const singleScaled = rawValue / maxSingle;
        const value = lerp(rawScaled, normVal, normalize);
        const valueOverlay = lerp(singleScaled, normVal, normalize);
        
        const y0 = lerp(0, stackedY, stack);
        const y1 = lerp(valueOverlay, stackedY + value, stack);
        
        catSegs.push({ origIdx, y0, y1, rawValue, color: COLORS[origIdx % COLORS.length] });
        stackedY += value;
      }
      result.push(catSegs);
    }
    return result;
  };
  
  const calcUnifiedGeometry = (allSegs, data, params, bounds, panZoom) => {
    const { bend, bendStack, gridiness, rotation, categoryRotation, segmentWidth, segmentGap, baseline, alignment, zoom, flatness } = params;
    const numCats = data.labels.length;
    const scale = Math.pow(2, zoom - 1);
    
    const maxHeights = allSegs.map(segs => Math.max(...segs.map(s => s.y1)));
    const globalMax = Math.max(...maxHeights);
    
    const geometries = [];
    
    const chartCenter = V.create(bounds.cx + panZoom.panX, bounds.cy + panZoom.panY);
    const chartW = bounds.width * scale;
    const chartH = bounds.height * scale;
    
    const cols = Math.ceil(Math.sqrt(numCats * 1.5));
    const rows = Math.ceil(numCats / cols);
    const cellW = chartW / cols;
    const cellH = chartH / rows;
    const gridTopLeft = V.create(chartCenter.x - cellW * cols / 2, chartCenter.y - cellH * rows / 2);
    
    const barTopLeft = V.create(chartCenter.x - chartW / 2, chartCenter.y - chartH / 2);
    const bandW = chartW / numCats;
    const barW = bandW * Math.max(0.001, segmentWidth) * (1 - segmentGap);
    
    const radialMaxR = Math.min(chartW, chartH) / 2 * 0.85;
    const radialRange = chartH;
    const radialMinR = chartH / 2;
    
    const donutR = Math.min(bandW, chartH) * 0.4;
    const pieR = Math.min(cellW, cellH) * 0.38;
    const donutInnerRatio = 1 - Math.max(0.05, segmentWidth);
    const donutGapAngle = segmentGap * 0.1;
    
    const baselineArcR = Math.min(chartW, chartH) / 2 * 0.5;
    const bendBlend = Math.min(1, bend / (Math.PI * 2));
    
    const effBend = Math.max(bend, 0.0001);
    const fullSliceAngle = effBend / numCats;
    const sliceAngle = fullSliceAngle * segmentWidth * (1 - segmentGap);
    
    for (let i = 0; i < numCats; i++) {
      const alignShift = alignment * (globalMax - maxHeights[i]);
      
      const barCatX = barTopLeft.x + (i + 0.5) * bandW;
      const barCatPosUnrotated = V.create(barCatX, chartCenter.y);
      const barCatPos = V.rotate(barCatPosUnrotated, chartCenter, categoryRotation);
      
      const catBaseAngle = -Math.PI / 2 + rotation + categoryRotation;
      const catAngle = catBaseAngle - (effBend / 2) + (i + 0.5) * fullSliceAngle;
      const radialCatPos = V.addPolar(chartCenter, baselineArcR, catAngle);
      
      const baselineCatPos = V.lerp(barCatPos, radialCatPos, bendBlend);
      
      const col = i % cols;
      const row = Math.floor(i / cols);
      const gridCatPos = V.create(
        gridTopLeft.x + (col + 0.5) * cellW,
        gridTopLeft.y + (row + 0.5) * cellH
      );
      
      const catCenter = V.lerp(baselineCatPos, gridCatPos, gridiness);
      
      const currentDonutR = lerp(donutR, pieR, gridiness);
      const currentDonutInnerR = currentDonutR * donutInnerRatio;
      
      for (const seg of allSegs[i]) {
        const next = allSegs[(i + 1)%numCats]?.find(s => s.origIdx === seg.origIdx);
        
        const y1L = seg.y1;
        const y0L = seg.y0;
        const y1R = lerp(next ? next.y1 : seg.y1, seg.y1, flatness);
        const y0R = lerp(next ? next.y0 : seg.y0, seg.y0, flatness);
        
        const toYBar = v => barTopLeft.y + chartH * (1 - (v + alignShift - baseline + 0.5));
        const halfBarW = barW / 2;
        
        const baselineSpineR = (radialMinR + (baseline - 0.5) * radialRange) * 0.5;
        const bendAngularSpan = bend;
        const barBaselineLength = chartW;
        const radialBaselineLength = 2 * Math.PI * baselineSpineR;
        const baselineArcLength = lerp(barBaselineLength, radialBaselineLength, bendBlend);
        
        const minBendAngularSpan = 0.0001;
        const bendSpineR = baselineArcLength / Math.max(bendAngularSpan, minBendAngularSpan);
        const bendCenterOffset = bendSpineR - baselineSpineR;
        const bendArcCenter = V.create(chartCenter.x, chartCenter.y + bendCenterOffset);
        const rotatedBendArcCenter = V.rotate(bendArcCenter, chartCenter, rotation + categoryRotation);
        
        const bendBaseAngle = -Math.PI / 2 + rotation + categoryRotation;
        const catCenterAngle = bendBaseAngle - (bend / 2) + (i + 0.5) * fullSliceAngle;
        const bendSliceAngle = fullSliceAngle * segmentWidth * (1 - segmentGap);
        const bendAStart = catCenterAngle - bendSliceAngle / 2;
        const bendAEnd = catCenterAngle + bendSliceAngle / 2;
        
        const heightScale = lerp(chartH, radialRange * 0.25, bendBlend);
        const baseShift = 1.5 * baseline * (1 - bendBlend);
        const h0L = (y0L + alignShift - baseShift) * heightScale;
        const h1L = (y1L + alignShift - baseShift) * heightScale;
        const h0R = (y0R + alignShift - baseShift) * heightScale;
        const h1R = (y1R + alignShift - baseShift) * heightScale;
        
        const r0L = bendSpineR + h0L;
        const r1L = bendSpineR + h1L;
        const r0R = bendSpineR + h0R;
        const r1R = bendSpineR + h1R;
        
        const sharedCorners = bend < 0.001 ? [
          V.rotate(V.create(barCatX - halfBarW, toYBar(y0L)), chartCenter, rotation + categoryRotation),
          V.rotate(V.create(barCatX + halfBarW, toYBar(y0R)), chartCenter, rotation + categoryRotation),
          V.rotate(V.create(barCatX + halfBarW, toYBar(y1R)), chartCenter, rotation + categoryRotation),
          V.rotate(V.create(barCatX - halfBarW, toYBar(y1L)), chartCenter, rotation + categoryRotation)
        ] : [
          V.addPolar(rotatedBendArcCenter, r0L, bendAStart),
          V.addPolar(rotatedBendArcCenter, r0R, bendAEnd),
          V.addPolar(rotatedBendArcCenter, r1R, bendAEnd),
          V.addPolar(rotatedBendArcCenter, r1L, bendAStart)
        ];
        
        const donutSpineR = (currentDonutR + currentDonutInnerR) / 2;
        const donutHalfThick = (currentDonutR - currentDonutInnerR) / 2;
        
        const barUpDir = rotation + categoryRotation - Math.PI / 2;
        const barRightDir = rotation + categoryRotation;
        
        const targetAngularSpan = bendStack * 2 * Math.PI;
        const barArcLength = chartH;
        const donutArcLength = 2 * Math.PI * donutSpineR;
        const arcLength = lerp(barArcLength, donutArcLength, bendStack);
        
        const minAngularSpan = 0.0001;
        const spineR = arcLength / Math.max(targetAngularSpan, minAngularSpan);
        const centerOffset = spineR - donutSpineR;
        const localArcCenter = V.addPolar(catCenter, centerOffset, barRightDir);
        
        const halfThick = lerp(halfBarW, donutHalfThick, bendStack);
        const outerR = spineR + halfThick;
        const innerR = spineR - halfThick;
        
        const baseAngle = barRightDir + Math.PI;
        const gapAngle = lerp(0, donutGapAngle, bendStack);
        
        const v0 = seg.y0 + alignShift;
        const v1 = seg.y1 + alignShift;
        
        const theta0 = baseAngle + (v0 - 0.5) * targetAngularSpan + gapAngle / 2;
        const theta1 = baseAngle + (v1 - 0.5) * targetAngularSpan - gapAngle / 2;
        
        const donutCorners = [
          V.addPolar(localArcCenter, outerR, theta0),
          V.addPolar(localArcCenter, innerR, theta0),
          V.addPolar(localArcCenter, innerR, theta1),
          V.addPolar(localArcCenter, outerR, theta1)
        ];
        
        const corners = sharedCorners.map((sc, idx) => V.lerp(sc, donutCorners[idx], bendStack));
        
        if (V.dist(corners[0], corners[1]) < 0.5 && V.dist(corners[2], corners[3]) < 0.5) continue;
        
        const edgeBendH = bendSliceAngle;
        const stackAngularSpan = (v1 - v0) * -targetAngularSpan;
        
        const bends = [
          -edgeBendH,
          stackAngularSpan,
          edgeBendH,
          -stackAngularSpan
        ];
        
        geometries.push({
          type: 'warpedpoly',
          corners,
          bends: bends.map(b => b * params.curviness),
          color: seg.color
        });
      }
      
      const barLabelPos = V.rotate(V.create(barCatX, barTopLeft.y + chartH + 20), chartCenter, rotation + categoryRotation);
      const radialLabelPos = V.addPolar(chartCenter, radialMaxR + 15, catAngle);
      const sharedLabelPos = V.lerp(barLabelPos, radialLabelPos, bendBlend);
      
      const donutLabelPos = V.create(catCenter.x, catCenter.y + currentDonutR + 15);
      const labelPos = V.lerp(sharedLabelPos, donutLabelPos, bendStack);
      
      geometries.push({
        type: 'label',
        x: labelPos.x,
        y: labelPos.y,
        text: data.labels[i],
        rotation: bendStack < 0.5 ? rotation + categoryRotation : 0,
        angle: bendBlend > 0.5 && bendStack < 0.5 ? catAngle : undefined
      });
    }
    
    return geometries;
  };
  
  const renderGeometries = (group, geoms, params) => {
    const { fillOpacity, strokeWidth, topWidth } = params;
    
    for (const g of geoms) {
      if (g.type === 'warpedpoly') {
        const pathD = WarpedPolygon.path(g.corners, g.bends);
        
        const path = createElement('path');
        path.setAttribute('d', pathD);
        path.setAttribute('fill', g.color);
        path.setAttribute('fill-opacity', g.opacity ?? fillOpacity);
        if (strokeWidth > 0) {
          path.setAttribute('stroke', g.color);
          path.setAttribute('stroke-width', strokeWidth);
        }
        group.appendChild(path);
        
        if (topWidth > 0) {
          const topD = WarpedPolygon.topPath(g.corners, g.bends);
          const topPath = createElement('path');
          topPath.setAttribute('d', topD);
          topPath.setAttribute('stroke', g.color);
          topPath.setAttribute('stroke-width', topWidth);
          topPath.setAttribute('stroke-linecap', 'round');
          topPath.setAttribute('fill', 'none');
          topPath.setAttribute('opacity', g.opacity ?? 1);
          group.appendChild(topPath);
        }
      } else if (g.type === 'label') {
        const text = createElement('text');
        text.setAttribute('x', g.x);
        text.setAttribute('y', g.y);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('fill', '#888');
        text.setAttribute('font-size', '11px');
        if (g.opacity !== undefined) text.setAttribute('opacity', g.opacity);
        
        let textRot = 0;
        if (g.angle !== undefined) {
          let deg = (g.angle * 180 / Math.PI) % 360;
          if (deg < 0) deg += 360;
          textRot = (deg > 90 && deg < 270) ? deg + 180 : deg;
        } else if (g.rotation !== undefined && g.rotation !== 0) {
          let deg = (g.rotation * 180 / Math.PI) % 360;
          if (deg < 0) deg += 360;
          textRot = (deg >= 67.5 && deg < 112.5) ? -90 : (deg >= 247.5 && deg < 292.5) ? 90 : 0;
        }
        
        if (textRot !== 0) {
          text.setAttribute('transform', `rotate(${textRot}, ${g.x}, ${g.y})`);
        }
        
        text.textContent = g.text;
        group.appendChild(text);
      }
    }
  };
  
  const render = (svg, data, params, panZoom = { panX: 0, panY: 0 }, showLegend = true) => {
    const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
    const width = viewBox[2];
    const height = viewBox[3];
    
    svg.innerHTML = '';
    
    const bounds = { cx: width / 2, cy: height / 2, width: width - 100, height: height - 100 };
    const mainGroup = createElement('g');
    
    const allSegs = calcAllSegments(data, params);
    const geoms = calcUnifiedGeometry(allSegs, data, params, bounds, panZoom);
    renderGeometries(mainGroup, geoms, params);
    
    svg.appendChild(mainGroup);
    
    if (showLegend) {
      renderLegend(svg, data.series, params.focusProduct, params.numProducts);
    }
  };
  
  const renderLegend = (svg, series, focusProduct, numProducts) => {
    const drawOrder = getDrawOrder(focusProduct, numProducts);
    const legendGroup = createElement('g');
    legendGroup.classList.add('chart-legend');
    
    // Legend sizing (scaled up for visibility when chart shrinks)
    const itemHeight = 28;
    const iconSize = 14;
    const fontSize = 14;
    const paddingX = 12;
    const paddingY = 10;
    const legendWidth = 100;
    const legendHeight = drawOrder.length * itemHeight + paddingY * 2;
    
    // Position at top-right
    const legendX = 800 - legendWidth - 15;
    const legendY = 15;
    legendGroup.setAttribute('transform', `translate(${legendX}, ${legendY})`);
    
    // Translucent background
    const bg = createElement('rect');
    bg.setAttribute('x', -paddingX);
    bg.setAttribute('y', -paddingY);
    bg.setAttribute('width', legendWidth + paddingX);
    bg.setAttribute('height', legendHeight);
    bg.setAttribute('fill', '#0f0f23');
    bg.setAttribute('fill-opacity', '0.75');
    bg.setAttribute('rx', 6);
    legendGroup.appendChild(bg);
    
    for (let p = 0; p < drawOrder.length; p++) {
      const origIdx = drawOrder[p];
      const g = createElement('g');
      g.setAttribute('transform', `translate(0, ${p * itemHeight})`);
      
      const rect = createElement('rect');
      rect.setAttribute('width', iconSize);
      rect.setAttribute('height', iconSize);
      rect.setAttribute('fill', COLORS[origIdx % COLORS.length]);
      rect.setAttribute('rx', 3);
      
      const text = createElement('text');
      text.setAttribute('x', iconSize + 8);
      text.setAttribute('y', iconSize - 2);
      text.setAttribute('fill', '#aaa');
      text.setAttribute('font-size', `${fontSize}px`);
      text.textContent = series[origIdx].name;
      
      g.appendChild(rect);
      g.appendChild(text);
      legendGroup.appendChild(g);
    }
    
    svg.appendChild(legendGroup);
  };
  
  const PRESETS = {
    'Stacked': {
      bend: 0, bendStack: 0, gridiness: 0, rotation: 0, categoryRotation: 0, segmentWidth: 0.8, segmentGap: 0.08,
      flatness: 1, stack: 1, baseline: 0.5, alignment: 0, curviness: 0,
      normalize: 0, fillOpacity: 1, strokeWidth: 0, topWidth: 0, zoom: 1
    },
    'Stream Graph': {
      bend: 0, bendStack: 0, gridiness: 0, rotation: 0, categoryRotation: 0, segmentWidth: 1, segmentGap: 0,
      flatness: 0, stack: 1, baseline: 0.5, alignment: 0, curviness: 0,
      normalize: 0, fillOpacity: 0.9, strokeWidth: 0, topWidth: 0, zoom: 1
    },
    'Area Chart': {
      bend: 0, bendStack: 0, gridiness: 0, rotation: 0, categoryRotation: 0, segmentWidth: 1, segmentGap: 0,
      flatness: 0, stack: 1, baseline: 0.5, alignment: 0, curviness: 0,
      normalize: 0, fillOpacity: 0.7, strokeWidth: 0, topWidth: 1, zoom: 1
    },
    'Line Chart': {
      bend: 0, bendStack: 0, gridiness: 0, rotation: 0, categoryRotation: 0, segmentWidth: 1, segmentGap: 0,
      flatness: 0, stack: 0, baseline: 0.5, alignment: 0, curviness: 0,
      normalize: 0, fillOpacity: 0.06, strokeWidth: 0, topWidth: 2.5, zoom: 1
    },
    'Bar Chart': {
      bend: 0, bendStack: 0, gridiness: 0, rotation: 0, categoryRotation: 0, segmentWidth: 0.92, segmentGap: 0,
      flatness: 1, stack: 0, baseline: 0.5, alignment: 0, curviness: 0,
      normalize: 0, fillOpacity: 0.1, strokeWidth: 1, topWidth: 3, zoom: 1
    },
    'Horizontal Bar': {
      bend: 0, bendStack: 0, gridiness: 0, rotation: 1.5708, categoryRotation: 0, segmentWidth: 0.8, segmentGap: 0.08,
      flatness: 1, stack: 1, baseline: 0.5, alignment: 0, curviness: 0,
      normalize: 0, fillOpacity: 1, strokeWidth: 0, topWidth: 0, zoom: 1
    },
    'Spider': {
      bend: 6.283, bendStack: 0, gridiness: 0, rotation: 0, categoryRotation: 0, segmentWidth: 1.0, segmentGap: 0.02,
      flatness: 0, stack: 1, baseline: 0.3, alignment: 0, curviness: 0,
      normalize: 0, fillOpacity: 0.15, strokeWidth: 0.5, topWidth: 2, zoom: 1
    },
    'Radial Bar': {
      bend: 6.283, bendStack: 0, gridiness: 0, rotation: 0, categoryRotation: 0, segmentWidth: 1.0, segmentGap: 0.02,
      flatness: 1, stack: 1, baseline: 0.3, alignment: 0, curviness: 1,
      normalize: 0, fillOpacity: 0.8, strokeWidth: 0.5, topWidth: 0, zoom: 1
    },
    'Radial Line': {
      bend: 6.283, bendStack: 0, gridiness: 0, rotation: 0, categoryRotation: 0, segmentWidth: 1.0, segmentGap: 0.02,
      flatness: 0, stack: 0, baseline: 0.3, alignment: 0, curviness: 0,
      normalize: 0, fillOpacity: 0, strokeWidth: 0.5, topWidth: 2.5, zoom: 1
    },
    'Donut Row': {
      bend: 0, bendStack: 1, gridiness: 0, rotation: 0, categoryRotation: 0, segmentWidth: 0.5, segmentGap: 0.15,
      flatness: 0, stack: 1, baseline: 0.5, alignment: 0, curviness: 1,
      normalize: 1, fillOpacity: 1, strokeWidth: 0, topWidth: 0, zoom: 1
    },
    'Donut Ring': {
      bend: 6.283, bendStack: 1, gridiness: 0, rotation: 0, categoryRotation: 0, segmentWidth: 0.5, segmentGap: 0.15,
      flatness: 0, stack: 1, baseline: 0.5, alignment: 0, curviness: 1,
      normalize: 1, fillOpacity: 1, strokeWidth: 0, topWidth: 0, zoom: 1
    },
    'Donut Chart': {
      bend: 0, bendStack: 1, gridiness: 1, rotation: 0, categoryRotation: 0, segmentWidth: 0.5, segmentGap: 0.15,
      flatness: 0, stack: 1, baseline: 0.5, alignment: 0, curviness: 1,
      normalize: 1, fillOpacity: 1, strokeWidth: 0, topWidth: 0, zoom: 1
    },
    'Pie Chart': {
      bend: 0, bendStack: 1, gridiness: 1, rotation: 0, categoryRotation: 0, segmentWidth: 1, segmentGap: 0,
      flatness: 0, stack: 1, baseline: 0.5, alignment: 0, curviness: 1,
      normalize: 1, fillOpacity: 0.5, strokeWidth: 1, topWidth: 0, zoom: 1
    }
  };
  
  return { render, generateData, PRESETS, COLORS, NUM_PRODUCTS };
})();


// ============================================================
// UI Configuration
// ============================================================

const SLIDER_CONFIG = [
  { group: 'Presets', id: 'presets', abbrev: 'Pre', type: 'presets' },
  { group: 'Data', id: 'data', abbrev: 'Dat', sliders: [
    { id: 'numCategories', label: 'months', min: 1, max: 12, step: 1, default: 6, isData: true },
    { id: 'numProducts', label: 'products', min: 1, max: 5, step: 1, default: 3 },
    { id: 'focusProduct', label: 'focusProduct', min: 1, max: 5, step: 1, default: 1 },
    { id: 'normalize', label: 'normalize', min: 0, max: 1, step: 0.01, default: 0 },
  ]},
  { group: 'View', id: 'view', abbrev: 'Vie', sliders: [
    { id: 'zoom', label: 'zoom', min: 0, max: 2, step: 0.01, default: 1 },
    { id: 'rotation', label: 'rotation', min: 0, max: 6.283, step: 0.01, default: 0, format: 'angle' },
    { id: 'categoryRotation', label: 'categoryRotation', min: 0, max: 6.283, step: 0.01, default: 0, format: 'angle' },
  ]},
  { group: 'Coordinate', id: 'coord', abbrev: 'Coo', sliders: [
    { id: 'bend', label: 'bend', min: 0, max: 6.283, step: 0.01, default: 0, format: 'angle' },
    { id: 'bendStack', label: 'bendStack', min: 0, max: 1, step: 0.01, default: 0 },
    { id: 'gridiness', label: 'gridiness', min: 0, max: 1, step: 0.01, default: 0 },
  ]},
  { group: 'Segment', id: 'segment', abbrev: 'Seg', sliders: [
    { id: 'segmentWidth', label: 'segmentWidth', min: 0.05, max: 1, step: 0.01, default: 0.8 },
    { id: 'segmentGap', label: 'segmentGap', min: 0, max: 0.5, step: 0.01, default: 0.05 },
    { id: 'curviness', label: 'curviness', min: 0, max: 1, step: 0.01, default: 1 },
    { id: 'flatness', label: 'flatness', min: 0, max: 1, step: 0.01, default: 1 },
  ]},
  { group: 'Stacking', id: 'stacking', abbrev: 'Sta', sliders: [
    { id: 'stack', label: 'stack', min: 0, max: 1, step: 0.01, default: 1 },
    { id: 'baseline', label: 'baseline', min: 0, max: 1, step: 0.01, default: 0.5 },
    { id: 'alignment', label: 'alignment', min: 0, max: 1, step: 0.01, default: 0 },
  ]},
  { group: 'Appearance', id: 'appearance', abbrev: 'App', sliders: [
    { id: 'fillOpacity', label: 'fillOpacity', min: 0, max: 1, step: 0.01, default: 1 },
    { id: 'strokeWidth', label: 'strokeWidth', min: 0, max: 5, step: 0.5, default: 0 },
    { id: 'topWidth', label: 'topWidth', min: 0, max: 5, step: 0.5, default: 0 },
  ]},
];


// ============================================================
// Demo Application
// ============================================================

(function() {
  let numCategories = 6;
  let data = OmniChart.generateData(numCategories);
  let params = { ...OmniChart.PRESETS['Stacked'], focusProduct: 1, numProducts: 3 };
  let panZoom = { panX: 0, panY: 0 };
  let isDragging = false;
  let dragStart = { x: 0, y: 0 };
  let panStart = { x: 0, y: 0 };
  let showLegend = true;
  
  const svg = document.getElementById('chart');
  const container = document.getElementById('chart-container');
  const controlsEl = document.getElementById('controls');
  const multiscrollerEl = document.getElementById('multiscroller');
  const legendToggle = document.getElementById('legend-toggle');
  
  // Touch detection
  const isTouchDevice = () => 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  
  const formatValue = (val, format) => {
    if (format === 'angle') return (val / Math.PI).toFixed(2) + 'œÄ';
    if (Number.isInteger(val)) return val;
    return val.toFixed(2);
  };
  
  // Track explicitly clicked section (shared between buildMultiscroller and setupScrollTracking)
  let clickedSectionId = null;
  
  // Build multiscroller buttons
  const buildMultiscroller = () => {
    for (const group of SLIDER_CONFIG) {
      const btn = document.createElement('button');
      btn.className = 'strip-btn';
      btn.dataset.target = `section-${group.id}`;
      btn.dataset.abbrev = group.abbrev || group.group.slice(0, 3);
      btn.dataset.full = group.group;
      btn.dataset.sectionId = group.id;
      btn.textContent = btn.dataset.abbrev;
      
      btn.addEventListener('click', () => {
        if (btn.classList.contains('inactive')) return;
        const target = document.getElementById(btn.dataset.target);
        if (target) {
          clickedSectionId = group.id;
          updateActiveStripButton(group.id);
          target.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      });
      multiscrollerEl.appendChild(btn);
    }
    updateStripButtonText();
    window.addEventListener('resize', updateStripButtonText);
  };
  
  // Update strip button text based on available height
  const updateStripButtonText = () => {
    const buttons = multiscrollerEl.querySelectorAll('.strip-btn');
    const stripHeight = multiscrollerEl.clientHeight;
    
    // Each character is roughly 9px in vertical writing mode, plus padding per button
    const charHeight = 9;
    const paddingPerButton = 12;
    
    // Sum actual height needed for each button's full text
    const neededTotal = SLIDER_CONFIG.reduce((sum, g) => {
      return sum + (g.group.length * charHeight) + paddingPerButton;
    }, 0);
    
    const useFull = stripHeight >= neededTotal;
    
    multiscrollerEl.classList.toggle('full-names', useFull);
    buttons.forEach(btn => {
      btn.textContent = useFull ? btn.dataset.full : btn.dataset.abbrev;
    });
  };
  
  const updateActiveStripButton = (activeId) => {
    document.querySelectorAll('.strip-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.target === `section-${activeId}`);
    });
  };
  
  // Track scroll position to highlight active section and mark inactive buttons
  const setupScrollTracking = () => {
    const updateButtonStates = () => {
      const scrollTop = controlsEl.scrollTop;
      const panelHeight = controlsEl.clientHeight;
      const scrollBottom = scrollTop + panelHeight;
      const maxScroll = controlsEl.scrollHeight - panelHeight;
      const hasScroll = maxScroll > 5;
      const isAtBottom = hasScroll && scrollTop >= maxScroll - 1;
      
      const buttons = multiscrollerEl.querySelectorAll('.strip-btn');
      let computedActiveSection = SLIDER_CONFIG[0].id;
      
      buttons.forEach((btn, i) => {
        const section = document.getElementById(`section-${SLIDER_CONFIG[i].id}`);
        if (!section) return;
        
        const sectionTop = section.offsetTop;
        const sectionBottom = sectionTop + section.offsetHeight;
        
        // Track which section would be active based on scroll position
        if (sectionTop <= scrollTop + 20) {
          computedActiveSection = SLIDER_CONFIG[i].id;
        }
        
        // Inactive if: at bottom and section is fully visible
        const fullyVisible = sectionTop >= scrollTop - 1 && sectionBottom <= scrollBottom + 1;
        const isInactive = isAtBottom && fullyVisible;
        
        btn.classList.toggle('inactive', isInactive);
      });
      
      // Use clicked section if set, otherwise computed from scroll
      if (!clickedSectionId) {
        updateActiveStripButton(computedActiveSection);
      }
    };
    
    // Clear clicked section on manual scroll
    controlsEl.addEventListener('wheel', () => { clickedSectionId = null; }, { passive: true });
    controlsEl.addEventListener('touchstart', () => { clickedSectionId = null; }, { passive: true });
    
    controlsEl.addEventListener('scroll', updateButtonStates);
    // Initial state
    updateButtonStates();
    // Update on resize too
    window.addEventListener('resize', updateButtonStates);
  };
  
  // ============================================================
  // Multiscroller Drag System
  // Unlocked when legend is hidden (showLegend = false)
  // Dragging a button scrolls its section into view:
  //   - Button at top of strip ‚Üí section top at panel top
  //   - Button at bottom of strip ‚Üí section bottom at panel bottom
  // ============================================================
  const setupMultiscrollerDrag = () => {
    let dragState = null;
    
    const isUnlocked = () => !showLegend;
    
    const getPointerY = (e) => {
      if (e.touches && e.touches.length > 0) return e.touches[0].clientY;
      if (e.changedTouches && e.changedTouches.length > 0) return e.changedTouches[0].clientY;
      return e.clientY;
    };
    
    const handleDragStart = (e, index) => {
      if (!isUnlocked()) return;
      
      const y = getPointerY(e);
      const stripRect = multiscrollerEl.getBoundingClientRect();
      
      dragState = {
        index,
        startY: y,
        stripTop: stripRect.top,
        stripHeight: stripRect.height
      };
      
      // Prevent text selection during drag
      e.preventDefault();
    };
    
    const handleDragMove = (e) => {
      if (!dragState) return;
      
      const y = getPointerY(e);
      const relY = y - dragState.stripTop;
      
      // t ranges from 0 (top of strip) to 1 (bottom of strip)
      const t = Math.max(0, Math.min(1, relY / dragState.stripHeight));
      
      // Get the section for the dragged button
      const sectionId = SLIDER_CONFIG[dragState.index].id;
      const section = document.getElementById(`section-${sectionId}`);
      if (!section) return;
      
      // Calculate scroll position
      // t=0: section top aligns with panel top
      // t=1: section bottom aligns with panel bottom
      const sectionTop = section.offsetTop;
      const sectionHeight = section.offsetHeight;
      const panelHeight = controlsEl.clientHeight;
      
      const scrollMin = sectionTop;
      const scrollMax = sectionTop + sectionHeight - panelHeight;
      const scrollTarget = scrollMin + t * (scrollMax - scrollMin);
      
      controlsEl.scrollTop = Math.max(0, scrollTarget);
    };
    
    const handleDragEnd = () => {
      dragState = null;
    };
    
    // Attach drag handlers to strip buttons
    const buttons = multiscrollerEl.querySelectorAll('.strip-btn');
    buttons.forEach((btn, i) => {
      btn.addEventListener('mousedown', (e) => handleDragStart(e, i));
      btn.addEventListener('touchstart', (e) => handleDragStart(e, i), { passive: false });
    });
    
    // Global move/end handlers
    window.addEventListener('mousemove', handleDragMove);
    window.addEventListener('touchmove', handleDragMove, { passive: true });
    window.addEventListener('mouseup', handleDragEnd);
    window.addEventListener('touchend', handleDragEnd);
  };
  
  const buildControls = () => {
    for (const group of SLIDER_CONFIG) {
      const groupEl = document.createElement('div');
      groupEl.className = 'control-group';
      groupEl.id = `section-${group.id}`;
      
      const h3 = document.createElement('h3');
      h3.textContent = group.group;
      groupEl.appendChild(h3);
      
      if (group.type === 'presets') {
        const presetsEl = document.createElement('div');
        presetsEl.className = 'presets';
        presetsEl.id = 'presets';
        
        for (const name of Object.keys(OmniChart.PRESETS)) {
          const btn = document.createElement('button');
          btn.className = 'preset-btn';
          btn.textContent = name;
          btn.onclick = () => applyPreset(name);
          presetsEl.appendChild(btn);
        }
        
        groupEl.appendChild(presetsEl);
      } else if (group.sliders) {
        for (const s of group.sliders) {
          const controlEl = document.createElement('div');
          controlEl.className = 'control';
          
          const label = document.createElement('label');
          const nameSpan = document.createElement('span');
          nameSpan.textContent = s.label;
          const valSpan = document.createElement('span');
          valSpan.id = `${s.id}-val`;
          
          const initVal = s.isData 
            ? numCategories
            : (params[s.id] ?? s.default);
          valSpan.textContent = formatValue(initVal, s.format);
          
          label.appendChild(nameSpan);
          label.appendChild(valSpan);
          
          const input = document.createElement('input');
          input.type = 'range';
          input.id = s.id;
          input.min = s.min;
          input.max = s.max;
          input.step = s.step;
          input.value = initVal;
          
          input.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            valSpan.textContent = formatValue(val, s.format);
            
            if (s.isData) {
              numCategories = val;
              data = OmniChart.generateData(numCategories);
            } else {
              params[s.id] = val;
            }
            
            renderChart();
            clearActivePreset();
          });
          
          controlEl.appendChild(label);
          controlEl.appendChild(input);
          groupEl.appendChild(controlEl);
        }
      }
      
      controlsEl.appendChild(groupEl);
    }
    
    // Hint for large screens
    const hint = document.createElement('p');
    hint.className = 'hint';
    hint.innerHTML = 'Drag to pan. Scroll to zoom.<br><b>bend</b>: curves shared baseline<br><b>bendStack</b>: bends each stack into donut<br><b>gridiness</b>: moves centers to grid<br><b>curviness</b>: scales edge bends (0=straight)';
    controlsEl.appendChild(hint);
  };
  
  const applyPreset = (name) => {
    const preset = OmniChart.PRESETS[name];
    if (!preset) return;
    
    const startParams = { ...params };
    const duration = 600;
    const startTime = performance.now();
    
    const animate = (currentTime) => {
      const elapsed = currentTime - startTime;
      const t = Math.min(1, elapsed / duration);
      const eased = 1 - Math.pow(1 - t, 3);
      
      for (const group of SLIDER_CONFIG) {
        if (!group.sliders) continue;
        for (const s of group.sliders) {
          if (s.isData) continue;
          if (preset[s.id] === undefined) continue;
          
          params[s.id] = startParams[s.id] + (preset[s.id] - startParams[s.id]) * eased;
          
          const input = document.getElementById(s.id);
          const valEl = document.getElementById(`${s.id}-val`);
          if (input) input.value = params[s.id];
          if (valEl) valEl.textContent = formatValue(params[s.id], s.format);
        }
      }
      
      renderChart();
      
      if (t < 1) {
        requestAnimationFrame(animate);
      } else {
        setActivePreset(name);
      }
    };
    
    requestAnimationFrame(animate);
  };
  
  const setActivePreset = (name) => {
    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.classList.toggle('active', btn.textContent === name);
    });
  };
  
  const clearActivePreset = () => {
    document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
  };
  
  // Legend toggle
  legendToggle.addEventListener('click', () => {
    showLegend = !showLegend;
    legendToggle.classList.toggle('active', showLegend);
    // Toggle multiscroller drag mode
    multiscrollerEl.classList.toggle('multiscroller-unlocked', !showLegend);
    renderChart();
  });
  
  // Pan handling (mouse)
  container.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragStart = { x: e.clientX, y: e.clientY };
    panStart = { ...panZoom };
  });
  
  window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    // Scale pan by the ratio of viewBox to actual rendered size
    const rect = svg.getBoundingClientRect();
    const scaleX = 800 / rect.width;
    const scaleY = 650 / rect.height;
    panZoom.panX = panStart.panX + (e.clientX - dragStart.x) * scaleX;
    panZoom.panY = panStart.panY + (e.clientY - dragStart.y) * scaleY;
    renderChart();
  });
  
  window.addEventListener('mouseup', () => isDragging = false);
  
  // Pan handling (touch)
  container.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      isDragging = true;
      dragStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      panStart = { ...panZoom };
    }
  }, { passive: true });
  
  container.addEventListener('touchmove', (e) => {
    if (!isDragging || e.touches.length !== 1) return;
    const rect = svg.getBoundingClientRect();
    const scaleX = 800 / rect.width;
    const scaleY = 650 / rect.height;
    panZoom.panX = panStart.panX + (e.touches[0].clientX - dragStart.x) * scaleX;
    panZoom.panY = panStart.panY + (e.touches[0].clientY - dragStart.y) * scaleY;
    renderChart();
  }, { passive: true });
  
  container.addEventListener('touchend', () => isDragging = false);
  
  // Wheel zoom (disabled on touch devices)
  container.addEventListener('wheel', (e) => {
    if (isTouchDevice()) return;
    e.preventDefault();
    params.zoom = Math.max(0, Math.min(2, params.zoom - e.deltaY * 0.001));
    const input = document.getElementById('zoom');
    const valEl = document.getElementById('zoom-val');
    if (input) input.value = params.zoom;
    if (valEl) valEl.textContent = formatValue(params.zoom);
    renderChart();
  }, { passive: false });
  
  const renderChart = () => {
    OmniChart.render(svg, data, params, panZoom, showLegend);
  };
  
  // Initialize
  buildMultiscroller();
  buildControls();
  setupScrollTracking();
  setupMultiscrollerDrag();
  setActivePreset('Stacked');
  updateActiveStripButton('presets');
  renderChart();
  
})();
</script>
</body>
</html>