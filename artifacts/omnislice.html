<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OmniSlice â€“ 3D Cutaway Viewer</title>
  <link rel="icon" type="image/x-icon" href="../wheel.ico">
  <script src="../js/utilities/nav.js"></script>
  <link rel="stylesheet" href="omnibase.css">
  <style>
    /* 3D canvas specific styles */
    .chart-container canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #0f0f23;
    }
  </style>
</head>
<body>
  <header class="header">
    <h1>OmniSlice</h1>
    <p class="subtitle">3D sphere with adjustable cutaway. Drag to rotate, scroll to zoom.</p>
  </header>
  
  <div class="layout">
    <div class="chart-container" id="chart-container"></div>
    <div class="controls-wrapper">
      <div class="multiscroller-strip" id="multiscroller"></div>
      <div class="controls" id="controls"></div>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script src="warped-polygon.js"></script>
  <script src="omnibase.js"></script>
  
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ============================================================
    // Presets
    // ============================================================
    
    const PRESETS = {
      'Wide': {
        wedgeStart: 0,
        wedgeAngle: 120,
        coreRadius: 0.6,
        planeOpacity: 1.0,
        coreOpacity: 1.0
      },
      'Narrow': {
        wedgeStart: 90,
        wedgeAngle: 60,
        coreRadius: 0.75,
        planeOpacity: 0.9,
        coreOpacity: 0.0
      }
    };

    // ============================================================
    // Slider Configuration
    // ============================================================
    
    const SLIDER_CONFIG = [
      { 
        group: 'Presets', 
        id: 'presets', 
        abbrev: 'Pre',
        type: 'presets' 
      },
      { 
        group: 'Cutaway', 
        id: 'cutaway', 
        abbrev: 'Cut',
        sliders: [
          { 
            id: 'wedgeStart', 
            label: 'Wedge start', 
            min: 0, 
            max: 360, 
            step: 1, 
            default: 0,
            format: 'degInt'
          },
          { 
            id: 'wedgeAngle', 
            label: 'Wedge angle', 
            min: 0, 
            max: 180, 
            step: 1, 
            default: 90,
            format: 'degInt'
          }
        ]
      },
      { 
        group: 'Core', 
        id: 'core', 
        abbrev: 'Core',
        sliders: [
          { 
            id: 'coreRadius', 
            label: 'Core radius', 
            min: 0.2, 
            max: 0.9, 
            step: 0.05, 
            default: 0.6
          }
        ]
      },
      { 
        group: 'Planes', 
        id: 'planes', 
        abbrev: 'Pln',
        sliders: [
          { 
            id: 'planeOpacity', 
            label: 'Plane opacity', 
            min: 0, 
            max: 1, 
            step: 0.05, 
            default: 0.9
          },
          { 
            id: 'coreOpacity', 
            label: 'Core on planes', 
            min: 0, 
            max: 1, 
            step: 0.05, 
            default: 1.0
          }
        ]
      }
    ];

    // ============================================================
    // Three.js Scene Setup
    // ============================================================
    
    class SphereScene {
      constructor(container) {
        this.container = container;
        
        // Scene setup
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(
          75, 
          container.clientWidth / container.clientHeight, 
          0.1, 
          1000
        );
        this.camera.position.set(2, 2, 4);
        
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(container.clientWidth, container.clientHeight);
        this.renderer.localClippingEnabled = true;
        container.appendChild(this.renderer.domElement);
        
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        
        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 5, 5);
        this.scene.add(light);
        this.scene.add(new THREE.AmbientLight(0x606060));

        const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
        light2.position.set(-5, -5, -5);
        this.scene.add(light2);

        // Clipping planes
        this.clipPlane1 = new THREE.Plane(new THREE.Vector3(1, 0, 0), 0);
        this.clipPlane2 = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        this.clippingPlanes = [this.clipPlane1, this.clipPlane2];
        
        // Create materials
        this.createMaterials();
        
        // Create geometry
        this.createGeometry();
        
        // Start animation loop
        this.animate();
      }
      
      createMaterials() {
        const textureLoader = new THREE.TextureLoader();
        const earthTex = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
        
        // Crust material
        this.crustMat = new THREE.MeshPhongMaterial({ 
          map: earthTex, 
          clippingPlanes: this.clippingPlanes,
          clipIntersection: true,
          side: THREE.DoubleSide 
        });
        
        // Core material
        this.coreMat = new THREE.MeshPhongMaterial({ 
          color: 0xff6600,
          emissive: 0x441100,
          clippingPlanes: this.clippingPlanes,
          clipIntersection: true,
          side: THREE.DoubleSide
        });
        
        // Grid material
        this.gridMat = new THREE.MeshBasicMaterial({ 
          color: 0xffffff, 
          wireframe: true, 
          transparent: true, 
          opacity: 0.2,
          clippingPlanes: this.clippingPlanes,
          clipIntersection: true 
        });
        
        // Plane materials (created with radial texture)
        this.planeMat1 = new THREE.MeshPhongMaterial({ 
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.9
        });

      
        this.planeMat2 = new THREE.MeshPhongMaterial({ 
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.9
        });
        
        // Create initial radial texture
        this.updateRadialTexture(0.6, 1.0);
      }
      
      createGeometry() {
        // Crust (outer sphere)
        const crustGeom = new THREE.SphereGeometry(1, 64, 64);
        this.crust = new THREE.Mesh(crustGeom, this.crustMat);
        this.scene.add(this.crust);
        
        // Core (inner sphere)
        this.coreRadius = 0.6;
        const coreGeom = new THREE.SphereGeometry(this.coreRadius, 64, 64);
        this.core = new THREE.Mesh(coreGeom, this.coreMat);
        this.scene.add(this.core);
        
        // Grid
        const gridGeom = new THREE.SphereGeometry(1.005, 32, 32);
        this.grid = new THREE.Mesh(gridGeom, this.gridMat);
        this.scene.add(this.grid);
        
        // Planar surfaces (semicircles)
        const planeGeom = new THREE.CircleGeometry(1, 64, -Math.PI / 2, Math.PI);
        
        this.plane1 = new THREE.Mesh(planeGeom, this.planeMat1);
        this.plane1.rotation.y = Math.PI / 2;
        this.scene.add(this.plane1);
        
        this.plane2 = new THREE.Mesh(planeGeom, this.planeMat2);
        this.plane2.rotation.z = Math.PI;
        this.scene.add(this.plane2);
      }
      
      createRadialTexture(coreRadius, coreOpacity) {
        const canvas = document.createElement('canvas');
        const size = 512;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        const centerX = size / 2;
        const centerY = size / 2;
        const maxRadius = size / 2;
        
        // Clear with transparency
        ctx.clearRect(0, 0, size, size);
        
        // Outer layer (Mantle/Crust)
        const mantleGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
        mantleGradient.addColorStop(0, '#d4a373');
        mantleGradient.addColorStop(0.5, '#8b6f47');
        mantleGradient.addColorStop(1, '#654321');
        
        ctx.fillStyle = mantleGradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Core region handling
        const coreRadiusPixels = maxRadius * coreRadius;
        
        if (coreOpacity < 1.0) {
          // Make transparent so we can see through
          ctx.globalCompositeOperation = 'destination-out';
          ctx.fillStyle = `rgba(0, 0, 0, ${1.0 - coreOpacity})`;
          ctx.beginPath();
          ctx.arc(centerX, centerY, coreRadiusPixels, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
        }
        
        if (coreOpacity > 0) {
          // Draw the core with specified opacity
          ctx.globalAlpha = coreOpacity;
          const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreRadiusPixels);
          coreGradient.addColorStop(0, '#ffff00');
          coreGradient.addColorStop(0.3, '#ff8800');
          coreGradient.addColorStop(0.7, '#ff4500');
          coreGradient.addColorStop(1, '#cc3300');
          
          ctx.fillStyle = coreGradient;
          ctx.beginPath();
          ctx.arc(centerX, centerY, coreRadiusPixels, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1.0;
        }
        
        // Detail lines
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.lineWidth = 1;
        for (let r = 0.2; r <= 1; r += 0.2) {
          ctx.beginPath();
          ctx.arc(centerX, centerY, maxRadius * r, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
      }
      
      updateRadialTexture(coreRadius, coreOpacity) {
        if (this.radialTexture) {
          this.radialTexture.dispose();
        }
        
        this.radialTexture = this.createRadialTexture(coreRadius, coreOpacity);
        this.planeMat1.map = this.radialTexture;
        this.planeMat2.map = this.radialTexture;
        this.planeMat1.needsUpdate = true;
        this.planeMat2.needsUpdate = true;
      }
      
      updateWedgeAngle(angleDegrees, startAngle) {
        const radStart = -(startAngle * Math.PI) / 180
        this.clipPlane1.normal.set(Math.cos(radStart), 0, Math.sin(radStart));
        this.plane1.rotation.y = -radStart + Math.PI / 2;
        const rad = radStart + Math.PI - (angleDegrees * Math.PI) / 180;
        this.clipPlane2.normal.set(Math.cos(rad), 0, Math.sin(rad));
        this.plane2.rotation.y = -rad + Math.PI / 2;
      }
      
      updateCoreRadius(radius) {
        this.coreRadius = radius;
        
        // Update core geometry
        this.scene.remove(this.core);
        this.core.geometry.dispose();
        this.core.geometry = new THREE.SphereGeometry(radius, 64, 64);
        this.scene.add(this.core);
      }
      
      updatePlaneOpacity(opacity) {
        this.planeMat1.opacity = opacity;
        this.planeMat2.opacity = opacity;
      }
      
      resize() {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
      }
      
      animate() {
        requestAnimationFrame(() => this.animate());
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
      }
    }

    // ============================================================
    // Initialize
    // ============================================================
    
    const container = document.getElementById('chart-container');
    const sphereScene = new SphereScene(container);
    
    // ============================================================
    // OmniBase Setup
    // ============================================================
    
    const base = new window.OmniBase({
      elements: {
        container: container,
        controls: document.getElementById('controls'),
        multiscroller: document.getElementById('multiscroller')
      },
      sliderConfig: SLIDER_CONFIG,
      presets: PRESETS,
      defaultPreset: 'Wide',
      enablePanZoom: false, // We handle our own controls via OrbitControls
      aspectRatio: 1,
      hintHtml: '<b>Drag</b> to rotate. <b>Scroll</b> to zoom.<br><b>Core opacity</b>: fade core on planes to see 3D interior',
      
      onRender: (params, panZoom, instance) => {
        sphereScene.updateWedgeAngle(params.wedgeAngle, params.wedgeStart);
        sphereScene.updateCoreRadius(params.coreRadius);
        sphereScene.updatePlaneOpacity(params.planeOpacity);
        sphereScene.updateRadialTexture(params.coreRadius, params.coreOpacity);
      },
      
      onParamChange: (id, value, isData, instance) => {
        // Individual parameter changes can be handled here if needed
        // For now, onRender handles all updates
      },
      
      onResize: (instance) => {
        sphereScene.resize();
      }
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
      sphereScene.resize();
    });
    
  </script>
</body>
</html>