<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="../wheel.ico" rel="icon">
    <title>Folder to ASCII Tree</title>
    <script src="../js/utilities/nav.js"></script>
    <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      padding: 40px 20px;
      color: #e4e4e7;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 8px;
      background: linear-gradient(90deg, #60a5fa, #a78bfa);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      text-align: center;
      color: #a1a1aa;
      margin-bottom: 40px;
      font-size: 1.1rem;
    }

    .drop-zone {
      border: 2px dashed #4b5563;
      border-radius: 16px;
      padding: 60px 40px;
      text-align: center;
      transition: all 0.3s ease;
      background: rgba(255, 255, 255, 0.02);
      cursor: pointer;
      position: relative;
    }

    .drop-zone:hover {
      border-color: #60a5fa;
      background: rgba(96, 165, 250, 0.05);
    }

    .drop-zone.drag-over {
      border-color: #a78bfa;
      background: rgba(167, 139, 250, 0.1);
      transform: scale(1.01);
    }

    .drop-zone-icon {
      font-size: 4rem;
      margin-bottom: 16px;
    }

    .drop-zone-text {
      font-size: 1.25rem;
      color: #d4d4d8;
      margin-bottom: 8px;
    }

    .drop-zone-hint {
      font-size: 0.9rem;
      color: #71717a;
    }

    .hidden-input {
      display: none;
    }

    .output-section {
      margin-top: 32px;
      display: none;
    }

    .output-section.visible {
      display: block;
      animation: fadeIn 0.4s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .output-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .output-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #d4d4d8;
    }

    .output-stats {
      font-size: 0.85rem;
      color: #71717a;
    }

    .copy-btn {
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      color: white;
      border: none;
      padding: 12px 28px;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .copy-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(139, 92, 246, 0.3);
    }

    .copy-btn:active {
      transform: translateY(0);
    }

    .copy-btn.copied {
      background: linear-gradient(135deg, #10b981, #059669);
    }

    .output-area {
      width: 100%;
      min-height: 400px;
      background: #0f0f14;
      border: 1px solid #27272a;
      border-radius: 12px;
      padding: 20px;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      font-size: 14px;
      line-height: 1.5;
      color: #a1a1aa;
      resize: vertical;
      outline: none;
      transition: border-color 0.2s;
    }

    .output-area:focus {
      border-color: #4b5563;
    }

    .actions {
      display: flex;
      gap: 12px;
      margin-top: 16px;
      justify-content: flex-end;
    }

    .secondary-btn {
      background: transparent;
      color: #a1a1aa;
      border: 1px solid #3f3f46;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .secondary-btn:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: #52525b;
      color: #d4d4d8;
    }

    .toast {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: #18181b;
      border: 1px solid #3f3f46;
      padding: 14px 24px;
      border-radius: 10px;
      font-size: 0.95rem;
      color: #e4e4e7;
      opacity: 0;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .toast-icon {
      color: #10b981;
      font-size: 1.2rem;
    }

    .options {
      display: flex;
      gap: 32px;
      margin-bottom: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .toggle {
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      user-select: none;
    }

    .toggle input {
      display: none;
    }

    .toggle-slider {
      width: 44px;
      height: 24px;
      background: #3f3f46;
      border-radius: 12px;
      position: relative;
      transition: background 0.2s ease;
    }

    .toggle-slider::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      background: #e4e4e7;
      border-radius: 50%;
      top: 3px;
      left: 3px;
      transition: transform 0.2s ease;
    }

    .toggle input:checked + .toggle-slider {
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
    }

    .toggle input:checked + .toggle-slider::after {
      transform: translateX(20px);
    }

    .toggle-label {
      font-size: 0.95rem;
      color: #a1a1aa;
    }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üìÅ Folder ‚Üí ASCII Tree</h1>
      <p class="subtitle">
        Drag & drop a folder to generate a copyable directory tree
      </p>
      <div class="options">
        <label class="toggle">
          <input type="checkbox" id="skipFiles" checked="">
          <span class="toggle-slider">
          </span>
          <span class="toggle-label">Skip .DS_Store and .git</span>
        </label>
        <label class="toggle">
          <input type="checkbox" id="addComments">
          <span class="toggle-slider">
          </span>
          <span class="toggle-label">Add # for comments</span>
        </label>
      </div>
      <div class="drop-zone" id="dropZone">
        <div class="drop-zone-icon">üóÇÔ∏è</div>
        <div class="drop-zone-text">Drop a folder here</div>
        <div class="drop-zone-hint">or click to browse</div>
        <input type="file" class="hidden-input" id="folderInput" webkitdirectory="" multiple="">
      </div>
      <div class="output-section" id="outputSection">
        <div class="output-header">
          <div>
            <span class="output-title" id="folderName">project/</span>
            <span class="output-stats" id="stats">
            </span>
          </div>
          <button class="copy-btn" id="copyBtn" onclick="copyToClipboard()">
            <span id="copyIcon">üìã</span>
            <span id="copyText">Copy to Clipboard</span>
          </button>
        </div>
        <textarea class="output-area" id="outputArea" readonly="">
        </textarea>
        <div class="actions">
          <button class="secondary-btn" onclick="clearOutput()">Clear</button>
          <button class="secondary-btn" onclick="downloadTxt()">
            Download .txt
          </button>
        </div>
      </div>
    </div>
    <div class="toast" id="toast">
      <span class="toast-icon">‚úì</span>
      <span id="toastMessage">Copied to clipboard!</span>
    </div>
    <script>
    const dropZone = document.getElementById('dropZone');
    const folderInput = document.getElementById('folderInput');
    const outputSection = document.getElementById('outputSection');
    const outputArea = document.getElementById('outputArea');
    const folderNameEl = document.getElementById('folderName');
    const statsEl = document.getElementById('stats');
    const copyBtn = document.getElementById('copyBtn');
    const toast = document.getElementById('toast');
    
    let lastEntries = null;
    let lastFiles = null;

    // Regenerate when toggles change
    document.getElementById('skipFiles').addEventListener('change', regenerate);
    document.getElementById('addComments').addEventListener('change', regenerate);
    
    function regenerate() {
      if (lastEntries) {
        processEntries(lastEntries);
      } else if (lastFiles) {
        processFiles(lastFiles);
      }
    }

    // Click to browse
    dropZone.addEventListener('click', () => folderInput.click());

    // Drag events
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('drag-over');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('drag-over');
    });

    dropZone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropZone.classList.remove('drag-over');
      
      const items = e.dataTransfer.items;
      if (items) {
        const entries = [];
        for (const item of items) {
          const entry = item.webkitGetAsEntry();
          if (entry) entries.push(entry);
        }
        if (entries.length > 0) {
          lastEntries = entries;
          lastFiles = null;
          await processEntries(entries);
        }
      }
    });

    // File input change
    folderInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      if (files.length > 0) {
        lastFiles = files;
        lastEntries = null;
        processFiles(files);
      }
    });

    async function processEntries(entries) {
      const tree = {};
      let rootName = entries[0].name;

      async function readEntry(entry, path = '') {
        if (entry.isFile) {
          return { type: 'file', name: entry.name };
        } else if (entry.isDirectory) {
          const dirReader = entry.createReader();
          const children = await new Promise((resolve) => {
            const results = [];
            const readBatch = () => {
              dirReader.readEntries((entries) => {
                if (entries.length === 0) {
                  resolve(results);
                } else {
                  results.push(...entries);
                  readBatch();
                }
              });
            };
            readBatch();
          });
          
          const childNodes = await Promise.all(
            children
              .filter(child => {
                if (!document.getElementById('skipFiles').checked) return true;
                return child.name !== '.DS_Store' && child.name !== '.git';
              })
              .map(child => readEntry(child, path + '/' + entry.name))
          );
          
          return {
            type: 'directory',
            name: entry.name,
            children: childNodes.sort((a, b) => {
              if (a.type !== b.type) return a.type === 'directory' ? -1 : 1;
              return a.name.localeCompare(b.name);
            })
          };
        }
      }

      const rootNode = await readEntry(entries[0]);
      generateAsciiTree(rootNode);
    }

    function processFiles(files) {
      // Build tree from file paths
      const tree = { type: 'directory', name: '', children: [] };
      
      // Find common root
      const paths = files.map(f => f.webkitRelativePath.split('/'));
      const rootName = paths[0][0];
      tree.name = rootName;

      // Build nested structure
      const skipFiles = document.getElementById('skipFiles').checked;
      files.filter(file => {
        if (!skipFiles) return true;
        const parts = file.webkitRelativePath.split('/');
        // Skip if any part of the path is .git or if the file is .DS_Store
        return !parts.includes('.git') && !file.name.endsWith('.DS_Store');
      }).forEach(file => {
        const parts = file.webkitRelativePath.split('/').slice(1); // Skip root
        let current = tree;
        
        parts.forEach((part, i) => {
          if (i === parts.length - 1) {
            // File
            current.children.push({ type: 'file', name: part });
          } else {
            // Directory
            let dir = current.children.find(c => c.type === 'directory' && c.name === part);
            if (!dir) {
              dir = { type: 'directory', name: part, children: [] };
              current.children.push(dir);
            }
            current = dir;
          }
        });
      });

      // Sort children
      function sortNode(node) {
        if (node.children) {
          node.children.sort((a, b) => {
            if (a.type !== b.type) return a.type === 'directory' ? -1 : 1;
            return a.name.localeCompare(b.name);
          });
          node.children.forEach(sortNode);
        }
      }
      sortNode(tree);

      generateAsciiTree(tree);
    }

    function generateAsciiTree(node) {
      let fileCount = 0;
      let dirCount = 0;
      const lines = [];

      function traverse(node, prefix = '', isLast = true, isRoot = true) {
        if (isRoot) {
          lines.push(node.name + '/');
          dirCount++;
        } else {
          const connector = isLast ? '‚îî‚îÄ ' : '‚îú‚îÄ ';
          const suffix = node.type === 'directory' ? '/' : '';
          lines.push(prefix + connector + node.name + suffix);
          
          if (node.type === 'directory') dirCount++;
          else fileCount++;
        }

        if (node.children) {
          const childPrefix = prefix + (isRoot ? '' : (isLast ? '   ' : '‚îÇ  '));
          node.children.forEach((child, i) => {
            const childIsLast = i === node.children.length - 1;
            traverse(child, childPrefix, childIsLast, false);
          });
        }
      }

      traverse(node);
      
      let asciiArt;
      if (document.getElementById('addComments').checked) {
        const maxLen = Math.max(...lines.map(l => l.length));
        const padTo = maxLen + 4;
        asciiArt = lines.map(l => l.padEnd(padTo) + '#').join('\n');
      } else {
        asciiArt = lines.join('\n');
      }
      
      outputArea.value = asciiArt;
      folderNameEl.textContent = node.name + '/';
      statsEl.textContent = `(${dirCount} directories, ${fileCount} files)`;
      outputSection.classList.add('visible');
    }

    function copyToClipboard() {
      navigator.clipboard.writeText(outputArea.value).then(() => {
        copyBtn.classList.add('copied');
        document.getElementById('copyIcon').textContent = '‚úì';
        document.getElementById('copyText').textContent = 'Copied!';
        showToast('Copied to clipboard!');
        
        setTimeout(() => {
          copyBtn.classList.remove('copied');
          document.getElementById('copyIcon').textContent = 'üìã';
          document.getElementById('copyText').textContent = 'Copy to Clipboard';
        }, 2000);
      });
    }

    function showToast(message) {
      document.getElementById('toastMessage').textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2500);
    }

    function clearOutput() {
      outputSection.classList.remove('visible');
      outputArea.value = '';
      folderInput.value = '';
      lastEntries = null;
      lastFiles = null;
    }

    function downloadTxt() {
      const blob = new Blob([outputArea.value], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = folderNameEl.textContent.replace('/', '') + '-tree.txt';
      a.click();
      URL.revokeObjectURL(url);
      showToast('Downloaded!');
    }
    </script>
  </body>
</html>
